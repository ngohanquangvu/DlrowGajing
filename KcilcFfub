os.environ["PLAYWRIGHT_BROWSERS_PATH"] = "./ms-playwright"
proxy_server = ""
username = ""
password = ""
def get_proxy():
    return proxy_server, username, password
def change_proxy(type):
    global status, proxy_server, username, password
    if type == 1:
        url = "https://api.zingproxy.com/getip/us/47a6fabaee3db42ab99fe46f3048e4b3e08092a6"
    else:
        url = "https://api.zproxy.me/api/rotateProxy/getNewProxy?apiKey=6A8167DC4986FF4568663B5A70B564D5&country=Vietnam&type=datacenter"
    while status:
        try:
            a = requests.get(url)
            if type == 1:
                proxy_server = f'http://36.50.52.132:8956'
                username = "nhqvu"
                password = "nhqvu"
                pass
            else:
                proxy_server = f'http://{a.json()["data"]["proxy"]}'
                username = a.json()["data"]["username"] 
                password = a.json()["data"]["password"]
        except:
            time.sleep(5)
            continue
        if type == 1:
            time.sleep(60)
        else:
            time.sleep(120)
def run_click(url, target, index):
    global running, proxy_server, username, password
    total_click = 0
    def run_inside(browser):    
            nonlocal total_click
            running[index] = ["Clicking", url, total_click]
            context = browser.new_context()
            page = context.new_page()
            refresh_count = 0
            max_refresh = 5

            while True:
                try:
                    page.goto(url, timeout=30000, wait_until="domcontentloaded")
                    check_timeout = timeout
                    start_time_run = time.time()
                    if "/video/" in url or "shorts" in url or "live" in url:
                        video_playing = False

                        while time.time() - start_time_run < check_timeout:
                            video_playing = page.evaluate("""
                                (function() {
                                    var videos = document.querySelectorAll('video');
                                    for (var i = 0; i < videos.length; i++) {
                                        if (!videos[i].paused) {
                                            return true;
                                        }
                                    }
                                    return false;
                                })();
                            """)
                            if video_playing:
                                break
                            time.sleep(0.5)
                            if page.evaluate("document.readyState") == "complete" and not video_playing:
                                time.sleep(7)
                                video_playing = page.evaluate("""
                                    (function() {
                                        var videos = document.querySelectorAll('video');
                                        for (var i = 0; i < videos.length; i++) {
                                            if (!videos[i].paused) {
                                                return true;
                                            }
                                        }
                                        return false;
                                    })();
                                """)
                                if video_playing:
                                    break

                                refresh_count += 1
                                if refresh_count > max_refresh:
                                    page.close()
                                    context.close()
                                    browser.close()
                                    break
                                page.reload()
                                start_time_run = time.time()

                        if refresh_count > max_refresh:
                            page.close()
                            context.close()
                            continue
                    else:
                        while time.time() - start_time_run < check_timeout:
                            try:
                                time.sleep(1)
                                if page.evaluate("document.readyState") == "complete":
                                    video_playing = True
                                    break
                            except:
                                continue
                    if video_playing:
                        scroll_height = page.evaluate("document.documentElement.scrollHeight")
                        random_scroll_height = random.randint(0, scroll_height)
                        page.evaluate(f"window.scrollTo(0, {random_scroll_height});")
                        time.sleep(1)
                        elements = page.query_selector_all("a[href]")
                        if elements:
                            random_element = random.choice(elements)
                            random_element.click()
                        time.sleep(5)

                    page.close()
                    context.close()
                    running[index] = ["Click Success", url, total_click]
                    total_click += 1
                    break
                except Exception as e:
                    page.close()
                    context.close()
                    break
    with sync_playwright() as playwright:
        while True:
            while True:
                try:
                    browser = playwright.firefox.launch(proxy={
                        "server": proxy_server,
                        "username": username,
                        "password": password
                    }, headless=True)
                    break
                except Exception as e:
                    continue
            threads = []
            for i in range(2):
                thread = threading.Thread(target=run_inside, args=(browser,))
                threads.append(thread)
            for thread in threads:   
                thread.start()
            for thread in threads:
                thread.join()
            if total_click >= target:
                running[index] = ["Done", url, total_click]
                break


def run(dem, index, proxy_type, lock):
    global list_url, running, url_complete, timeout, proxy_server, username, password
    headless = True
    while True:
        with lock:
            if len(list_url) == 0:
                break
            url = list_url.pop(0)
        run_click(url, dem, index)
        
def process_url(dem, index, lock, proxy_type):
    run(dem, index, proxy_type, lock)

def checking():
    global url_complete, running, start_time, status
    while status:
        for j in range(len(running)):
            if running[j][0]=="Click Success" or running[j][0]=="Done":
                print(f"\033[32mThread {j+1}: {running[j][0]} | {running[j][1]} | {running[j][2]}\033[0m")
                print("")
            elif running[j][0]=="Clicking":
                print(f"\033[33mThread {j+1}: {running[j][0]} | {running[j][1]} | {running[j][2]}\033[0m")
                print("")
            else:
                print(f"\033[36mThread {j+1}: {running[j][0]} | {running[j][1]} | {running[j][2]}\033[0m")
                print("")
        end_time = time.time()

        execution_time = end_time - start_time
        hours, rem = divmod(execution_time, 3600)
        minutes, seconds = divmod(rem, 60)
        formatted_time = "{:0>2}:{:0>2}:{:05.2f}".format(int(hours),int(minutes),seconds)

        print(f"\033[33mProcess: {formatted_time} - Url complete: {url_complete}\033[0m")
        time.sleep(1)
        os.system('cls')


start_tool = input("Enter để băt đầu...")
list_url = askopenfilename(title="Chọn file chứa danh sách URL cần truy cập", filetypes=[("Text files", "*.txt")])
list_url = [line.strip() for line in open(list_url, "r").readlines()]
print(f"Data: {len(list_url)} urls")
while True:
    try:
        dem = int(input("Nhập số lần truy cập: "))
        break
    except ValueError:
        print("Số lần truy cập phải là số nguyên")
        continue
while True:
    try:
        luong = int(input("Nhập số luồng: "))
        break
    except ValueError:
        print("Số luồng phải là số nguyên")
        continue
while True:
    try:
        timeout = int(input("Nhập timeout(s): "))
        break
    except ValueError:
        print("Số timeout phải là số nguyên")
        continue

while True:
    try:
        proxy_type = int(input("Chọn loại proxy (1. Proxy us |2. Proxy Vn): "))
        if proxy_type not in [1, 2]:
            print("Loại proxy không hợp lệ")
            continue
        break
    except ValueError:
        print("Loại proxy phải là số nguyên")
        continue


url_complete = 0
running = [['','',''] for _ in range(luong)]
lock = threading.Lock()
status = True
start_time = time.time()
t = threading.Thread(target=checking)
t.start()
tt = threading.Thread(target=change_proxy, args=(proxy_type,))
tt.start()
threads = []
for i in range(luong):
    thread = threading.Thread(target=process_url, args=(dem, i, lock, proxy_type,))
    threads.append(thread)
    thread.start()
for thread in threads:
    thread.join()
t.join()
tt.join()
end_time = time.time()

execution_time = end_time - start_time
hours, rem = divmod(execution_time, 3600)
minutes, seconds = divmod(rem, 60)
formatted_time = "{:0>2}:{:0>2}:{:05.2f}".format(int(hours),int(minutes),seconds)

print(f"\033[33mProcess: {formatted_time}\033[0m")
output = input("Nhấn Enter để thoát...")
status = False
